<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passkey 认证</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        .container {
            display: none; /* 完全隐藏界面 */
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        .loading-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 300px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            font-size: 18px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
        }
        .loading-subtitle {
            font-size: 14px;
            color: #86868b;
        }
    </style>
</head>
<body>
    <!-- 隐藏的容器，用于逻辑处理 -->
    <div class="container" style="display: none;">
        <div id="status"></div>
    </div>
    
    <!-- 加载遮罩层 -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-text" id="loadingText">正在处理认证请求...</div>
            <div class="loading-subtitle" id="loadingSubtitle">请稍候</div>
        </div>
    </div>

    <script>
        const API = 'http://localhost:3001'; // 后端 API 地址
        
        // 工具函数
        function updateLoadingUI(text, subtitle = '请稍候') {
            const loadingText = document.getElementById('loadingText');
            const loadingSubtitle = document.getElementById('loadingSubtitle');
            loadingText.textContent = text;
            loadingSubtitle.textContent = subtitle;
        }

        function hideLoadingOverlay() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = 'none';
        }

        function showLoading(message, subtitle = '请稍候') {
            updateLoadingUI(message, subtitle);
        }

        function showSuccess(message) {
            updateLoadingUI('✅ ' + message, '正在返回应用...');
            setTimeout(() => {
                hideLoadingOverlay();
            }, 1500);
        }

        function showError(message) {
            updateLoadingUI('❌ ' + message, '请重试或返回应用');
            setTimeout(() => {
                hideLoadingOverlay();
            }, 3000);
        }

        function bufToBase64url(buf) {
            return btoa(String.fromCharCode(...new Uint8Array(buf)))
                .replaceAll('+','-').replaceAll('/','_').replaceAll('=','');
        }
        
        function base64urlToBuf(b64url) {
            const pad = '='.repeat((4 - b64url.length % 4) % 4);
            const b64 = (b64url + pad).replaceAll('-','+').replaceAll('_','/');
            const raw = atob(b64);
            const arr = new Uint8Array(raw.length);
            for (let i=0;i<raw.length;i++) arr[i] = raw.charCodeAt(i);
            return arr.buffer;
        }

        // 检查 WebAuthn 支持
        function checkWebAuthnSupport() {
            if (!window.PublicKeyCredential) {
                showError('当前浏览器不支持 WebAuthn/Passkey 功能');
                return false;
            }
            if (!navigator.credentials) {
                showError('当前浏览器不支持 Credentials API');
                return false;
            }
            return true;
        }

        // 执行注册流程
        async function performRegistration(username) {
            if (!checkWebAuthnSupport()) return;
            
            showLoading('正在准备注册 Passkey...');
            
            try {
                // 1. 获取注册选项
                showLoading('正在获取注册选项...');
                const resp = await fetch(API + '/webauthn/registration/options', {
                    method: 'POST', 
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ username, displayName: username }),
                });
                
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}: ${await resp.text()}`);
                }
                
                const opts = await resp.json();
                
                // 2. 转换字段格式
                opts.challenge = base64urlToBuf(opts.challenge);
                opts.user.id = new TextEncoder().encode(opts.user.id);
                if (opts.excludeCredentials) {
                    opts.excludeCredentials = opts.excludeCredentials.map(c => ({
                        ...c, id: base64urlToBuf(c.id)
                    }));
                }
                
                // 3. 调用 WebAuthn API 创建凭证
                showLoading('请使用 Face ID 或 Touch ID 完成注册...');
                
                // 添加延迟确保用户看到提示，并确保页面完全加载
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                console.log('准备调用 WebAuthn API 创建凭证，选项:', opts);
                
                // 直接调用 WebAuthn API
                const attResp = await navigator.credentials.create({ 
                    publicKey: {
                        ...opts,
                        timeout: 60000, // 60秒超时
                        userVerification: 'required'
                    }
                });
                
                console.log('WebAuthn API 响应:', attResp);
                if (!attResp) {
                    showError('用户取消注册');
                    return;
                }
                
                // 4. 转换响应格式
                showLoading('正在验证注册信息...');
                const clientDataJSON = bufToBase64url(attResp.response.clientDataJSON);
                const attestationObject = bufToBase64url(attResp.response.attestationObject);
                const data = {
                    id: attResp.id,
                    rawId: bufToBase64url(attResp.rawId),
                    type: attResp.type,
                    response: { clientDataJSON, attestationObject },
                };
                
                // 5. 提交到后端验证
                const v = await fetch(API + '/webauthn/registration/verify', {
                    method: 'POST', 
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ username, attResp: data }),
                }).then(r => r.json());
                
                if (v.verified) {
                    showSuccess('Passkey 注册成功！');
                    
                    // 延迟后重定向回应用
                    setTimeout(() => {
                        const urlParams = new URLSearchParams(window.location.search);
                        const state = urlParams.get('state');
                        if (state) {
                            window.location.href = `passkeydemo://auth?success=true&state=${state}`;
                        }
                    }, 2000);
                } else {
                    showError('注册验证失败');
                }
                
            } catch (error) {
                console.error('注册错误:', error);
                console.error('错误详情:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                
                // 提供更友好的错误信息
                let friendlyMessage = error.message;
                if (error.message.includes('invalid state')) {
                    friendlyMessage = '认证器状态无效，请重试';
                } else if (error.message.includes('not allowed')) {
                    friendlyMessage = '浏览器不允许此操作，请检查权限设置';
                } else if (error.message.includes('timeout')) {
                    friendlyMessage = '操作超时，请重试';
                }
                
                showError(`注册失败: ${friendlyMessage}`);
            }
        }

        // 执行登录流程
        async function performLogin(username) {
            console.log('开始登录流程，用户名:', username);
            
            if (!checkWebAuthnSupport()) return;
            
            showLoading('正在准备登录...');
            
            try {
                // 1. 获取认证选项
                console.log('正在获取认证选项...');
                const resp = await fetch(API + '/webauthn/authentication/options', {
                    method: 'POST', 
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ username }),
                });
                
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}: ${await resp.text()}`);
                }
                
                const opts = await resp.json();
                console.log('收到认证选项:', opts);
                
                // 2. 转换字段格式
                opts.challenge = base64urlToBuf(opts.challenge);
                if (opts.allowCredentials) {
                    opts.allowCredentials = opts.allowCredentials.map(c => ({
                        ...c, id: base64urlToBuf(c.id)
                    }));
                }
                
                // 3. 调用 WebAuthn API 获取认证
                showLoading('请使用 Face ID 或 Touch ID 完成登录...');
                
                // 添加延迟确保用户看到提示，并确保页面完全加载
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                console.log('准备调用 WebAuthn API，选项:', opts);
                
                // 直接调用 WebAuthn API
                const authResp = await navigator.credentials.get({ 
                    publicKey: {
                        ...opts,
                        timeout: 60000, // 60秒超时
                        userVerification: 'required'
                    }
                });
                
                console.log('WebAuthn API 响应:', authResp);
                if (!authResp) {
                    showError('用户取消登录');
                    return;
                }
                
                // 4. 转换响应格式
                const data = {
                    id: authResp.id,
                    rawId: bufToBase64url(authResp.rawId),
                    type: authResp.type,
                    response: {
                        clientDataJSON: bufToBase64url(authResp.response.clientDataJSON),
                        authenticatorData: bufToBase64url(authResp.response.authenticatorData),
                        signature: bufToBase64url(authResp.response.signature),
                        userHandle: authResp.response.userHandle ? bufToBase64url(authResp.response.userHandle) : null,
                    }
                };
                
                // 5. 提交到后端验证
                const v = await fetch(API + '/webauthn/authentication/verify', {
                    method: 'POST', 
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ username, authResp: data }),
                }).then(r => r.json());
                
                if (v.verified && v.code) {
                    showSuccess('登录成功！获得授权码');
                    
                    // 延迟后重定向回应用
                    setTimeout(() => {
                        const urlParams = new URLSearchParams(window.location.search);
                        const state = urlParams.get('state');
                        if (state) {
                            window.location.href = `passkeydemo://auth?code=${v.code}&state=${state}`;
                        }
                    }, 2000);
                } else {
                    showError('登录验证失败');
                }
                
            } catch (error) {
                console.error('登录错误:', error);
                console.error('错误详情:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                
                // 提供更友好的错误信息
                let friendlyMessage = error.message;
                if (error.message.includes('invalid state')) {
                    friendlyMessage = '认证器状态无效，请重试';
                } else if (error.message.includes('not allowed')) {
                    friendlyMessage = '浏览器不允许此操作，请检查权限设置';
                } else if (error.message.includes('timeout')) {
                    friendlyMessage = '操作超时，请重试';
                }
                
                showError(`登录失败: ${friendlyMessage}`);
            }
        }

        // 页面加载时自动执行认证流程
        window.addEventListener('load', () => {
            // 确保页面完全加载后再执行
            setTimeout(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const username = urlParams.get('username');
                const action = urlParams.get('action'); // 'register' 或 'login'
                
                if (!username) {
                    showError('缺少用户名参数');
                    return;
                }
                
                if (!action) {
                    showError('缺少操作类型参数');
                    return;
                }
                
                console.log('开始认证流程:', { username, action });
                
                // 根据操作类型执行相应流程
                if (action === 'register') {
                    performRegistration(username);
                } else if (action === 'login') {
                    performLogin(username);
                } else {
                    showError('无效的操作类型');
                }
            }, 500); // 延迟500ms确保页面完全加载
        });
    </script>
</body>
</html>
